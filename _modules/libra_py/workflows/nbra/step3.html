

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>libra_py.workflows.nbra.step3 &mdash; Libra 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Libra
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/libra_py.html">libra_py</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Libra</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>libra_py.workflows.nbra.step3</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for libra_py.workflows.nbra.step3</h1><div class="highlight"><pre>
<span></span><span class="c1">#*********************************************************************************</span>
<span class="c1">#* Copyright (C) 2017-2019 Brendan A. Smith, Wei Li, Alexey V. Akimov</span>
<span class="c1">#*</span>
<span class="c1">#* This file is distributed under the terms of the GNU General Public License</span>
<span class="c1">#* as published by the Free Software Foundation, either version 2 of</span>
<span class="c1">#* the License, or (at your option) any later version.</span>
<span class="c1">#* See the file LICENSE in the root directory of this distribution</span>
<span class="c1">#* or &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#*</span>
<span class="c1">#*********************************************************************************/</span>
<span class="c1">#</span>
<span class="c1">#  </span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: step3</span>
<span class="sd">   :platform: Unix, Windows</span>
<span class="sd">   :synopsis: This module is designed to convert the results of QE calculations </span>
<span class="sd">       (KS orbital energies and time-overlaps in the KS basis) to the generic Hvib</span>
<span class="sd">       matrices, which account for:</span>

<span class="sd">           - state reordering;</span>
<span class="sd">           - phase corrections;</span>
<span class="sd">           - multi-electron wavefunction (Slater determinants) and spin-adaptation</span>
<span class="sd">           - scissor operator corrections to energy levels</span>

<span class="sd">.. moduleauthor:: Brendan A. Smith, Wei Li, and Alexey V. Akimov</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;cygwin&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cyglibra_core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;linux&quot;</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;linux2&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">liblibra_core</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">mapping</span>
<span class="kn">import</span> <span class="nn">util.libutil</span> <span class="k">as</span> <span class="nn">comn</span>
<span class="kn">import</span> <span class="nn">libra_py.tsh</span> <span class="k">as</span> <span class="nn">tsh</span>
<span class="kn">import</span> <span class="nn">libra_py.units</span> <span class="k">as</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">libra_py.data_read</span> <span class="k">as</span> <span class="nn">data_read</span>
<span class="kn">import</span> <span class="nn">libra_py.hungarian</span> <span class="k">as</span> <span class="nn">hungarian</span>


<div class="viewcode-block" id="get_step2_data"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.get_step2_data">[docs]</a><span class="k">def</span> <span class="nf">get_step2_data</span><span class="p">(</span><span class="n">_params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A light function to obtain the step2 data</span>

<span class="sd">    Args:</span>
<span class="sd">        params ( dictionary ): Control paramerter of this type of simulation. Can include the follwing keys:</span>

<span class="sd">            * **params[&quot;basis&quot;]** ( string ): describes if one is using either the spin-diabatic (non spin-orbit coupling) </span>
<span class="sd">                                              or is using the spin-adiabatic (spin orbit-coupling)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_params</span><span class="p">)</span>
    <span class="n">spin_basis</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;basis&quot;</span><span class="p">]</span>

    <span class="c1"># Fetching the overlap matricies</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="s2">&quot;data_re_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;S_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_ks_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_re_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_re&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_im_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;S_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_ks_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_im_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_im&quot;</span>  <span class="p">}</span> <span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">data_read</span><span class="o">.</span><span class="n">get_data_sets</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1">#print (&quot;\n&quot;)</span>
    <span class="c1">#S[0][0].show_matrix()</span>
    <span class="c1">#print (S[0][0].get(0,0))</span>
    <span class="c1">#sys.exit(0)</span>

    <span class="c1"># Fetching the time-derivative overlap matricies</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="s2">&quot;data_re_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;St_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_ks_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_re_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_re&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_im_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;St_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_ks_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_im_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_im&quot;</span>  <span class="p">}</span> <span class="p">)</span> 
    <span class="n">St</span> <span class="o">=</span> <span class="n">data_read</span><span class="o">.</span><span class="n">get_data_sets</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1">#print (&quot;\n&quot;)</span>
    <span class="c1">#St[0][0].show_matrix()</span>
    <span class="c1">#sys.exit(0)</span>
 
    <span class="c1"># Fetching the vibronic Hamiltonian matricies</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="s2">&quot;data_re_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;hvib_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_re_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_re&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_im_prefix&quot;</span> <span class="p">:</span> <span class="s2">&quot;hvib_&quot;</span><span class="o">+</span><span class="n">spin_basis</span><span class="o">+</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;data_im_suffix&quot;</span> <span class="p">:</span> <span class="s2">&quot;_im&quot;</span>  <span class="p">}</span> <span class="p">)</span> 
    <span class="n">Hvib_ks</span> <span class="o">=</span> <span class="n">data_read</span><span class="o">.</span><span class="n">get_data_sets</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1">#print (&quot;\n&quot;)</span>
    <span class="c1">#Hvib_ks[0][0].show_matrix()</span>
    <span class="c1">#sys.exit(0)</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">St</span><span class="p">,</span> <span class="n">Hvib_ks</span></div>




<div class="viewcode-block" id="print_SD_basis"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.print_SD_basis">[docs]</a><span class="k">def</span> <span class="nf">print_SD_basis</span><span class="p">(</span><span class="n">SD_basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just a light function to print the SD basis</span>

<span class="sd">    Args:</span>
<span class="sd">        SD_basis ( list of lists of ints ): Slater determinant basis in terms of Kohn-Sham orbital indicies</span>

<span class="sd">            Possible ground state configurations</span>

<span class="sd">            Ex. 1. SD_basis[0] = [ 5, -15 ]</span>
<span class="sd">            Ex. 2. SD_basis[0] = [ 2, 3, 4, 5, -12, -13, -14, -15 ]</span>

<span class="sd">            Possible ground state configurations</span>

<span class="sd">            Ex. 1. SD_basis[N &gt; 0] = [ 6, -15 ]</span>
<span class="sd">            Ex. 2. SD_basis[N &gt; 0] = [ 2, 3, 4, 6, -12, -13, -14, -15 ]</span>

<span class="sd">            Where we have 10 alpha and beta spin orbitals, and the cbm index for the alpha spin-channel is 5</span>
<span class="sd">            and the cbm index for the beta spin-channel is 15. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SD_basis</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; GS: &quot;</span><span class="p">,</span> <span class="n">SD_basis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; ES &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="n">SD_basis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;WARNING: The Slater determinant bases above may not be sorted based on their energies</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>




<div class="viewcode-block" id="sort_SD_energies"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.sort_SD_energies">[docs]</a><span class="k">def</span> <span class="nf">sort_SD_energies</span><span class="p">(</span><span class="n">Hvib</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function goes into the Hvib (SD basis) files and sorts the energies</span>
<span class="sd">    For each Hvib file, we are going to obtain a list of lists of orbital index and energy pair</span>
<span class="sd">    These orbital index and energy pairs for each step will be sorted based on energies  </span>

<span class="sd">    Args:</span>
<span class="sd">        Hvib ( list of lists of CMATRIX objects ): vibronic Hamiltonian in the Slater determinant basis</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ntraj</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hvib</span><span class="p">)</span>
    <span class="n">nsnaps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>   
    <span class="n">nSD</span> <span class="o">=</span> <span class="n">Hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>

    <span class="n">orbital_index_energy_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntraj</span><span class="p">):</span>

        <span class="n">orbital_index_energy_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">snap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsnaps</span><span class="p">):</span>

            <span class="n">index_energy_pairs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">sd_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSD</span><span class="p">):</span>
                <span class="n">index_energy_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span> <span class="n">sd_index</span><span class="p">,</span> <span class="n">Hvib</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">sd_index</span><span class="p">,</span> <span class="n">sd_index</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="p">]</span>  <span class="p">)</span>

            <span class="n">sorted_index_energy_pairs</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span> <span class="n">index_energy_pairs</span>  <span class="p">)</span> 
            <span class="n">orbital_index_energy_pairs</span><span class="p">[</span><span class="n">traj</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sorted_index_energy_pairs</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">orbital_index_energy_pairs</span></div>




<div class="viewcode-block" id="output_sorted_Hvibs"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.output_sorted_Hvibs">[docs]</a><span class="k">def</span> <span class="nf">output_sorted_Hvibs</span><span class="p">(</span><span class="n">Hvib</span><span class="p">,</span> <span class="n">orbital_index_energy_pairs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function outputs the vibronic Hamiltonians in the SD basis according to their sorted order</span>

<span class="sd">    Args:</span>
<span class="sd">        Hvib ( list of lists of CMATRIX objects ): vibronic Hamiltonian in the Slater determinant basis</span>
<span class="sd">        orbital_index_energy_pairs ( list of lists of lists of lists ): orbital index and energy pair lists for each step and nuclear trajectory</span>
<span class="sd">                               Ex. orbital_index_energy_pairs[i][j][k][0] = kth slater determinant index at the jth step on the ith nuclear trajectory   </span>
<span class="sd">                               Ex. orbital_index_energy_pairs[i][j][k][1] = kth slater determinant energy at the jth step on the ith nuclear trajectory   </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ntraj</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbital_index_energy_pairs</span><span class="p">)</span>
    <span class="n">nsnaps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbital_index_energy_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">nSD</span>    <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbital_index_energy_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">Hvibs_sorted</span>   <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ntraj</span> <span class="p">):</span>

        <span class="n">rd_sorted</span> <span class="o">=</span> <span class="s2">&quot;res_sorted_traj&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;rm -r &quot;</span><span class="o">+</span><span class="n">rd_sorted</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mkdir &quot;</span><span class="o">+</span><span class="n">rd_sorted</span><span class="p">)</span>

        <span class="n">Hvibs_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">snap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsnaps</span> <span class="p">):</span>
            <span class="n">Hvib_sorted</span>  <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nSD</span><span class="p">,</span> <span class="n">nSD</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSD</span> <span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSD</span> <span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">orbital_index_energy_pairs</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">][</span> <span class="n">i</span> <span class="p">][</span> <span class="mi">0</span> <span class="p">]</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">orbital_index_energy_pairs</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">][</span> <span class="n">j</span> <span class="p">][</span> <span class="mi">0</span> <span class="p">]</span>
                    <span class="n">Hvib_sorted</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Hvib</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>

            <span class="n">Hvibs_sorted</span><span class="p">[</span> <span class="n">traj</span> <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Hvib_sorted</span> <span class="p">)</span>
            <span class="n">Hvibs_sorted</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Hvib_sorted_</span><span class="si">%i</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rd_sorted</span><span class="p">,</span> <span class="n">snap</span><span class="p">))</span>
            <span class="n">Hvibs_sorted</span><span class="p">[</span> <span class="n">traj</span> <span class="p">][</span> <span class="n">snap</span> <span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Hvib_sorted_</span><span class="si">%i</span><span class="s2">_im&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rd_sorted</span><span class="p">,</span> <span class="n">snap</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Hvibs_sorted</span></div>




<div class="viewcode-block" id="build_SD_basis"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.build_SD_basis">[docs]</a><span class="k">def</span> <span class="nf">build_SD_basis</span><span class="p">(</span><span class="n">data_dim</span><span class="p">,</span> <span class="n">cbm_alpha_index</span><span class="p">,</span> <span class="n">alpha_include</span><span class="p">,</span> <span class="n">cbm_beta_index</span><span class="p">,</span> <span class="n">beta_include</span><span class="p">,</span> <span class="n">excitation_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a Slater Determinant basis based on the indexing notation scheme used in Libra</span>

<span class="sd">    Args:</span>
<span class="sd">        data_dim (int): how many rows or columns in the vibronic Hamiltonian matrix. This will be an even number becuase the </span>
<span class="sd">                        number of alpha orbtials should equal the number of beta orbitals</span>
<span class="sd">        cbm_(alpha/beta)_index (int): index of VBM (or HOMO) in the matrix of the vibronic Hamiltonian </span>
<span class="sd">                                      (row or column index). Note, this index is from 1 </span>
<span class="sd">        (alpha/beta)_include (int): how many orbitals to include from the cbm_(alpha/beta)_index</span>
<span class="sd">        excitation_type (int):  0: Make SDs with beta electrons excited</span>
<span class="sd">                                1: Make SDs with alpha electrons excited</span>
<span class="sd">                                2: Make two sets of SDs, one for beta and one for alpha electrons excited  </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_same_spin_orbitals</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">data_dim</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>

    <span class="n">alpha_electrons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">beta_electrons</span>  <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check for potential errors</span>
    <span class="k">if</span> <span class="n">data_dim</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;The dimensions of your vibronic Hamiltonian matrix (or whatever data you wish to pass to the function build_SD) must be even&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exiting now ..&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cbm_alpha_index</span> <span class="o">&gt;</span> <span class="n">num_same_spin_orbitals</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;You must have the same number of alpha and beta spin-orbitals in your basis. The index of the CBM for the alpha spin-orbitals</span><span class="se">\</span>
<span class="s2"> cannot be greater than 1/2 the total number of spin orbitals &quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exiting now&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">cbm_alpha_index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;The index of the CBM for the alpha spin-orbitals must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exiting now&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">cbm_beta_index</span> <span class="o">&lt;=</span> <span class="n">num_same_spin_orbitals</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;You must have the same number of alpha and beta spin-orbitals in your basis. The index of the CBM for the beta spin-orbitals</span><span class="se">\</span>
<span class="s2"> cannot be less than 1/2 the total number of spin orbitals &quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exiting now&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">cbm_beta_index</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_same_spin_orbitals</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;The index of the CBM for the beta spin-orbitals must be &lt; total number of spin-orbitals&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exiting now&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="n">alpha_include</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">num_same_spin_orbitals</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Cannot include more alpha spin-orbitals than there are&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Including the maximum amount&quot;</span><span class="p">)</span>
        <span class="n">alpha_include</span> <span class="o">=</span> <span class="n">num_same_spin_orbitals</span> <span class="o">-</span> <span class="n">cbm_alpha_index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;New value for alpha_include = &quot;</span><span class="p">,</span> <span class="n">alpha_include</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cbm_beta_index</span> <span class="o">+</span> <span class="n">beta_include</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_same_spin_orbitals</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Cannot include more beta spin-orbitals than there are&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Including the maximum amount&quot;</span><span class="p">)</span>
        <span class="n">beta_include</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_same_spin_orbitals</span> <span class="o">-</span> <span class="n">cbm_beta_index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;New value for beta_include = &quot;</span><span class="p">,</span> <span class="n">beta_include</span><span class="p">)</span> 

    <span class="c1"># Make ground state SD</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">cbm_alpha_index</span> <span class="o">-</span> <span class="n">alpha_include</span><span class="p">,</span> <span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">alpha_electrons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">cbm_beta_index</span>  <span class="o">-</span> <span class="n">beta_include</span><span class="p">,</span> <span class="n">cbm_beta_index</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">beta_electrons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">i</span> <span class="p">)</span>

    <span class="n">gs_SD</span> <span class="o">=</span> <span class="n">alpha_electrons</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">beta_electrons</span><span class="p">[:]</span> 

    <span class="c1"># Make excited state SDs</span>
    <span class="n">es_SD</span>    <span class="o">=</span> <span class="p">[]</span>
    <span class="n">SD_basis</span> <span class="o">=</span> <span class="p">[]</span>
   
    <span class="c1"># Excite only alpha electrons </span>
    <span class="k">if</span> <span class="n">excitation_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alpha_electrons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">alpha_include</span><span class="p">):</span>

                <span class="c1">#es_sd = [ j if electron == i else electron for electron in gs_SD[:] ]  # compact version</span>
                <span class="n">es_sd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">electron</span> <span class="ow">in</span> <span class="n">gs_SD</span><span class="p">[:]:</span>
                    <span class="k">if</span> <span class="n">electron</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">j</span> <span class="p">)</span> 
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">electron</span> <span class="p">)</span>
                <span class="n">es_SD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">es_sd</span> <span class="p">)</span>

    <span class="c1"># Excite only beta electrons</span>
    <span class="k">elif</span> <span class="n">excitation_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>   
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">beta_electrons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cbm_beta_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cbm_beta_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">beta_include</span><span class="p">):</span>

                <span class="c1">#es_sd = [ -j if electron == i else electron for electron in gs_SD[:] ]  # compact version</span>
                <span class="n">es_sd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">electron</span> <span class="ow">in</span> <span class="n">gs_SD</span><span class="p">[:]:</span>
                    <span class="k">if</span> <span class="n">electron</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">j</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">electron</span> <span class="p">)</span>
                <span class="n">es_SD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">es_sd</span> <span class="p">)</span>
    
    <span class="c1"># Excite both alpha and beta electrons</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alpha_electrons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cbm_alpha_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">alpha_include</span><span class="p">):</span>

                <span class="c1">#es_sd = [ j if electron == i else electron for electron in gs_SD[:] ]  # compact version</span>
                <span class="n">es_sd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">electron</span> <span class="ow">in</span> <span class="n">gs_SD</span><span class="p">[:]:</span>
                    <span class="k">if</span> <span class="n">electron</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">j</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">electron</span> <span class="p">)</span>
                <span class="n">es_SD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">es_sd</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">beta_electrons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cbm_beta_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cbm_beta_index</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">beta_include</span><span class="p">):</span>

                <span class="c1">#es_sd = [ -j if electron == i else electron for electron in gs_SD[:] ]  # compact version</span>
                <span class="n">es_sd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">electron</span> <span class="ow">in</span> <span class="n">gs_SD</span><span class="p">[:]:</span>
                    <span class="k">if</span> <span class="n">electron</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">j</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">es_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">electron</span> <span class="p">)</span>
                <span class="n">es_SD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">es_sd</span> <span class="p">)</span>

    <span class="n">SD_basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">gs_SD</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">es_SD</span><span class="p">)):</span>
        <span class="n">SD_basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">es_SD</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">SD_basis</span></div>




<div class="viewcode-block" id="get_Lowdin"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.get_Lowdin">[docs]</a><span class="k">def</span> <span class="nf">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">    Find the S_i_half for the S matrix - alpha and beta components</span>

<span class="sd">    Args: </span>
<span class="sd">        S ( CMATRIX(2N, 2N) ): is a matrix of MO overlaps. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                S = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                S_{aa}  &amp; S_{ab} \\\</span>
<span class="sd">                S_{ba}  &amp; S_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, S_xy are the overlaps of the MOs for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (S_aa_i_half, S_bb_i_half), where:</span>

<span class="sd">            * S_aa_i_half ( CMATRIX(N,N) ): S_aa^{-1/2} - inverse square root matrix for the alpha-alpha block</span>
<span class="sd">            * S_bb_i_half ( CMATRIX(N,N) ): S_bb^{-1/2} - inverse square root matrix for the beta-beta block</span>
<span class="sd">          </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="n">S_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

    <span class="n">is_inv</span> <span class="o">=</span> <span class="n">FullPivLU_rank_invertible</span><span class="p">(</span><span class="n">S_aa</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, S_aa is not invertible, Exiting Program&quot;</span><span class="p">);</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">is_inv</span> <span class="o">=</span> <span class="n">FullPivLU_rank_invertible</span><span class="p">(</span><span class="n">S_bb</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, S_bb is not invertible, Exiting Program&quot;</span><span class="p">);</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">S_aa_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_aa_i_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">sqrt_matrix</span><span class="p">(</span><span class="n">S_aa</span><span class="p">,</span> <span class="n">S_aa_half</span><span class="p">,</span> <span class="n">S_aa_i_half</span><span class="p">)</span>

    <span class="n">S_bb_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_bb_i_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">sqrt_matrix</span><span class="p">(</span><span class="n">S_bb</span><span class="p">,</span> <span class="n">S_bb_half</span><span class="p">,</span> <span class="n">S_bb_i_half</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S_aa_i_half</span><span class="p">,</span> <span class="n">S_bb_i_half</span></div>




<div class="viewcode-block" id="apply_normalization"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_normalization">[docs]</a><span class="k">def</span> <span class="nf">apply_normalization</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Transforms the input transition density matrix computed with potentially</span>
<span class="sd">    non-orthogonalized orbitals such that it would correspond to the properly</span>
<span class="sd">    orthonormalized ones</span>

<span class="sd">    Args: </span>
<span class="sd">        S ( CMATRIX(2N, 2N) ): is a matrix of MO overlaps S_ij = &lt;i|j&gt;. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                S = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                S_{aa}  &amp; S_{ab} \\\</span>
<span class="sd">                S_{ba}  &amp; S_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, S_xy are the overlaps of the MOs for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">        St ( CMATRIX(2N, 2N) ): the transition density matrix St_ij = &lt;i|d/dt|j&gt;. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                St = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                St_{aa}  &amp; St_{ab} \\\</span>
<span class="sd">                St_{ba}  &amp; St_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, St_xy are the transition density matrix for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">    Returns:</span>
<span class="sd">        None: but the input matrix ```St``` is changed</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>
    
    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="n">St_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>  <span class="n">St_ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>
    <span class="n">St_ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>  <span class="n">St_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    
        <span class="n">U1_a</span><span class="p">,</span> <span class="n">U1_b</span> <span class="o">=</span> <span class="n">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>    <span class="c1"># time n</span>
        <span class="n">U2_a</span><span class="p">,</span> <span class="n">U2_b</span> <span class="o">=</span> <span class="n">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># time n+1          </span>
    
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
    
        <span class="n">St_aa</span> <span class="o">=</span> <span class="n">U1_a</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_aa</span> <span class="o">*</span> <span class="n">U2_a</span>
        <span class="n">St_ab</span> <span class="o">=</span> <span class="n">U1_a</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_ab</span> <span class="o">*</span> <span class="n">U2_b</span>
        <span class="n">St_ba</span> <span class="o">=</span> <span class="n">U1_b</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_ba</span> <span class="o">*</span> <span class="n">U2_a</span>
        <span class="n">St_bb</span> <span class="o">=</span> <span class="n">U1_b</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_bb</span> <span class="o">*</span> <span class="n">U2_b</span>
    
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span></div>




<div class="viewcode-block" id="get_Lowdin_general"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.get_Lowdin_general">[docs]</a><span class="k">def</span> <span class="nf">get_Lowdin_general</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">    Find the S_i_half for the S matrix</span>
<span class="sd">    Args: </span>
<span class="sd">        S ( CMATRIX(N, N) ): is a matrix of MO overlaps. </span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: S_i_half, where:</span>
<span class="sd">            * S_i_half ( CMATRIX(N,N) ): S^{-1/2} - inverse square root matrix</span>
<span class="sd">          </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">num_of_cols</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>
    <span class="n">is_inv</span> <span class="o">=</span> <span class="n">FullPivLU_rank_invertible</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, S is not invertible, Exiting Program&quot;</span><span class="p">);</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">S_half</span>   <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_i_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">sqrt_matrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_half</span><span class="p">,</span> <span class="n">S_i_half</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S_i_half</span></div>




<div class="viewcode-block" id="apply_orthonormalization_general"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_orthonormalization_general">[docs]</a><span class="k">def</span> <span class="nf">apply_orthonormalization_general</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Transforms the input transition density matrix computed with potentially</span>
<span class="sd">    non-orthogonalized orbitals such that it would correspond to the properly</span>
<span class="sd">    orthonormalized ones</span>

<span class="sd">    Args: </span>
<span class="sd">        S  ( CMATRIX(N, N) ): is a matrix of MO overlaps S_ij = &lt;i|j&gt;</span>
<span class="sd">        St ( CMATRIX(N, N) ): the transition density matrix St_ij = &lt;i|d/dt|j&gt;</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: but the input matricies ```S``` and ```St``` are changed   </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="c1"># For St</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">get_Lowdin_general</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c1"># time n</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">get_Lowdin_general</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># time n+1          </span>
        <span class="c1">#print(&quot;St matrix before&quot;)</span>
        <span class="c1">#St[i].show_matrix()</span>
        <span class="n">St_normalized</span> <span class="o">=</span> <span class="n">U1</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">U2</span>
        <span class="c1">#print(&quot;St matrix after&quot;)</span>
        <span class="c1">#St_normalized.show_matrix()</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_normalized</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">)))</span>

    <span class="c1"># For S</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">get_Lowdin_general</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># time n</span>
        <span class="c1">#print(&quot;S matrix before&quot;)</span>
        <span class="c1">#S[i].show_matrix()</span>
        <span class="n">S_normalized</span> <span class="o">=</span> <span class="n">U1</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">U1</span>
        <span class="c1">#print(&quot;S matrix after&quot;)</span>
        <span class="c1">#S_normalized.show_matrix()</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S_normalized</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">)))</span></div>





<div class="viewcode-block" id="make_cost_mat"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.make_cost_mat">[docs]</a><span class="k">def</span> <span class="nf">make_cost_mat</span><span class="p">(</span><span class="n">orb_mat_inp</span><span class="p">,</span> <span class="n">en_mat_inp</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Makes the cost matrix from a given TDM and information on states&#39; energies</span>

<span class="sd">    Args:    </span>
<span class="sd">        orb_mat_inp  ( CMATRIX(nstates,nstates) or MATRIX(nstates,nstate) ): the transition density matrix</span>
<span class="sd">            TDM in a given basis. Here, ```nstates``` - the number of states (e.g. the number of doubly-occupied</span>
<span class="sd">            orbitals )</span>

<span class="sd">        en_mat_inp ( MATRIX(nstates, nstates) ): Matrix of energies in a given basis [units: a.u.]</span>

<span class="sd">        alpha ( float ): Parameter controlling the range of the orbitals that can participate in</span>
<span class="sd">            the reordering. Setting is to 0 makes all orbitals be considered for reordering</span>
<span class="sd">            Setting it to a large number makes the effective number of orbitals participating</span>
<span class="sd">            in the reordering smaller - this can be used to turn off the reordering. [units: a.u.^-1]</span>

<span class="sd">    Returns: </span>
<span class="sd">        MATRIX(nstates, nstates): the matrix of the cost values for different pairs of states</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="n">orb_mat_inp</span><span class="o">.</span><span class="n">num_of_cols</span>
    <span class="n">cost_mat</span> <span class="o">=</span> <span class="n">MATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>

            <span class="n">s</span> <span class="o">=</span> <span class="n">orb_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
            <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">en_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">en_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">dE</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cost_mat</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_mat</span></div>



<div class="viewcode-block" id="apply_state_reordering"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_state_reordering">[docs]</a><span class="k">def</span> <span class="nf">apply_state_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Performs the state&#39;s identity reordering in a given basis for all time steps.</span>
<span class="sd">    This is reflects in the corresponding changess of the TDM.</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(nstates, nstates) ): TDM for each timestep</span>
<span class="sd">        E ( list of CMATRIX(nstates, nstates) ): energies of all states at every step</span>
<span class="sd">        params ( dictionary ): parameters controlling the reordering</span>
<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): option to select the state reordering algorithm </span>
<span class="sd">                Available options:</span>
<span class="sd">                    - 1: older version developed by Kosuke Sato, may not the working all the times</span>
<span class="sd">                    - 2: Munkres-Kuhn (Hungarian) method [default]</span>

<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): a parameter that controls how </span>
<span class="sd">                many states will be included in the reordering</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: but changes the input St object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span> <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="c1"># Initialize the cumulative permutation as the identity permutation</span>
    <span class="n">perm_cum_aa</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for alpha spatial orbitals</span>
    <span class="n">perm_cum_bb</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for beta  spatial orbtials</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_cum_aa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">perm_cum_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Current permutation</span>
    <span class="n">perm_t_aa</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> 
    <span class="n">perm_t_bb</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_t_aa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">perm_t_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


    <span class="c1"># Temporary matrices for the Hungarian method</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="n">en_mat_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> 
    <span class="n">en_mat_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A simple approach based on permuations - but this is not robust</span>
<span class="sd">            may have loops</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">perm_t</span> <span class="o">=</span> <span class="n">get_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># apply the cumulative permutation  </span>
            <span class="n">update_permutation</span><span class="p">(</span><span class="n">perm_t</span><span class="p">,</span> <span class="n">perm_cum</span><span class="p">)</span>

            <span class="c1"># apply the permutation</span>
            <span class="c1"># Because St = &lt;psi(t)|psi(t+dt)&gt; - we permute only columns</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>

            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The Hungarian approach</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

            <span class="c1"># Extract the alpha and beta orbtial energies</span>
            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">en_mat_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">en_mat_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

            <span class="c1"># Permute rows </span>
            <span class="n">aa</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>   <span class="n">ab</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">)</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">);</span>   <span class="n">bb</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>


            <span class="c1"># compute the cost matrices for diagonal blocks</span>
            <span class="n">cost_mat_aa</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">en_mat_aa</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>
            <span class="n">cost_mat_bb</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">en_mat_bb</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>          

            <span class="c1"># Solve the optimal assignment problem for diagonal blocks</span>
            <span class="n">res_aa</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat_aa</span><span class="p">)</span>
            <span class="n">res_bb</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat_bb</span><span class="p">)</span>
   

            <span class="c1"># Convert the list of lists into the permutation object</span>
            <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">res_aa</span><span class="p">:</span>
                <span class="n">perm_t_aa</span><span class="p">[</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; alpha | alpha &gt; this becomes a new value: perm_t = P_{n+1}</span>
            <span class="k">for</span> <span class="n">rb</span> <span class="ow">in</span> <span class="n">res_bb</span><span class="p">:</span>
                <span class="n">perm_t_bb</span><span class="p">[</span><span class="n">rb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; beta | beta &gt; this becomes a new value: perm_t = P_{n+1}   </span>

            <span class="c1"># Permute the blocks by col</span>
            <span class="n">aa</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>  <span class="n">ab</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>  <span class="n">bb</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>

            <span class="c1"># Reconstruct St matrix </span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span></div>




<div class="viewcode-block" id="do_phase_corr"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.do_phase_corr">[docs]</a><span class="k">def</span> <span class="nf">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase1</span><span class="p">,</span> <span class="n">St</span><span class="p">,</span> <span class="n">cum_phase2</span><span class="p">,</span> <span class="n">phase_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function changes the St matrix according to</span>
<span class="sd">    the previous cumulative phases and the current </span>
<span class="sd">    phase correction as:</span>

<span class="sd">    St = &lt;bra|ket&gt;</span>

<span class="sd">    St -&gt; St = F_n * St * (F_{n+1})^+ = F_n * St * (F_{n})^+ * (f_{n+1})^+</span>

<span class="sd">    Args:</span>
<span class="sd">        cum_phase1 ( CMATRIX(nstates, 1) ): cumulative phase corrections up to step n (F_n) for bra-vectors</span>
<span class="sd">        St         ( CMATRIX(nstates, nstates) ): input/output TDM to be processed: </span>
<span class="sd">            could be alpha-alpha, beta-beta, alpha-beta, or beta-alpha sub-blocks</span>
<span class="sd">        cum_phase2 ( CMATRIX(nstates, 1) ): cumulative phase corrections up to step n (F_n) for ket-vectors</span>
<span class="sd">        phase_i    ( CMATRIX(nstates, 1) ): the current step phase corrections (f_{n+1}) for a given pair of vectors</span>


<span class="sd">    Returns: </span>
<span class="sd">        None: but changes the input matrix St</span>
<span class="sd">  </span>
<span class="sd">    &quot;&quot;&quot;</span>
   
    <span class="n">nstates</span> <span class="o">=</span> <span class="n">St</span><span class="o">.</span><span class="n">num_of_rows</span>

    <span class="c1">### Correct the TDM matrix ###</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">fab</span> <span class="o">=</span> <span class="n">cum_phase1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">cum_phase2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">phase_i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
            <span class="n">St</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">fab</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_phase_correction"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_phase_correction">[docs]</a><span class="k">def</span> <span class="nf">apply_phase_correction</span><span class="p">(</span><span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs the phase correction according to:         </span>
<span class="sd">    Akimov, A. V. J. Phys. Chem. Lett, 2018, 9, 6096</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(N,N) ): St_ij[n] = &lt;i(n)|j(n+1)&gt; transition density matrix for </span>
<span class="sd">            the timestep n, where N is the number of spin-orbitals in the active space. </span>
<span class="sd">            Spin-orbitals, not just orbitals! So it is composed as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                St = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                St_{aa}  &amp; St_{ab} \\\</span>
<span class="sd">                St_{ba}  &amp; St_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">    Returns: </span>
<span class="sd">        None: but changes the input St matrices</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="c1">### Initiate the cumulative phase correction factors ###    </span>
    <span class="n">cum_phase_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># F(n-1)  cumulative phase</span>
    <span class="n">cum_phase_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># F(n-1)  cumulative phase</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">cum_phase_aa</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span>
        <span class="n">cum_phase_bb</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span>


    <span class="n">St_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">St_ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">St_ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">St_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>

        <span class="c1">### Compute the instantaneous phase correction factors for diag. blocks ###</span>
        <span class="n">phase_i_aa</span> <span class="o">=</span> <span class="n">compute_phase_corrections</span><span class="p">(</span><span class="n">St_aa</span><span class="p">)</span>   <span class="c1"># f(i)</span>
        <span class="n">phase_i_bb</span> <span class="o">=</span> <span class="n">compute_phase_corrections</span><span class="p">(</span><span class="n">St_bb</span><span class="p">)</span>   <span class="c1"># f(i)       </span>

        <span class="c1">### Do the  phase correstions for the diag. blocks ###</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="p">)</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="p">)</span>
        
        <span class="c1">### Do the  phase correstions for the off-diag. blocks ###</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="p">)</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="p">)</span>

        <span class="c1">### Push the corrected diag. blocks to orig. St matrix ###</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

        <span class="c1">### Update the cumulative phase correction factors for diag. blocks ###</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">cum_phase_aa</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">cum_phase_bb</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">))</span></div>




<div class="viewcode-block" id="sac_matrices"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.sac_matrices">[docs]</a><span class="k">def</span> <span class="nf">sac_matrices</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">S_ks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function makes the Phi-to-Chi (P2C) transformation matrix.</span>
<span class="sd">    Normalization factros for the Chi states are computed based on the </span>
<span class="sd">    overlaps of Phi states.</span>
<span class="sd">    &lt; Chi_i | Chi_j &gt; = 1</span>
<span class="sd">    = N_i * N_j * &lt; Phi_i - Phi_i&#39; | Phi_j - Phi_j&#39; &gt; = 1</span>

<span class="sd">    coeff [List of lists] - P2C as initialized by the user</span>
<span class="sd">    basis [Phi basis] - as initialized by the user </span>
<span class="sd">    S_ks  [CMATRIX] - Time overlap matrix of elementary KS orbtials, from step2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_chi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
    <span class="n">n_phi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">P2C</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">n_phi</span><span class="p">,</span> <span class="n">n_chi</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_chi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_phi</span><span class="p">):</span>
            <span class="n">P2C</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">coeff</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Compute the overlaps of the SDs:</span>
    <span class="c1">#</span>
    <span class="n">Ssd</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">S_ks</span><span class="p">)</span>

    <span class="c1"># Normalize the Chi wavefunctions #</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">P2C</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">Ssd</span> <span class="o">*</span> <span class="n">P2C</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_chi</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">P2C</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in CHI normalizaiton: some combination gives zero norm</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P2C</span></div>


<div class="viewcode-block" id="scale_H_vib"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.scale_H_vib">[docs]</a><span class="k">def</span> <span class="nf">scale_H_vib</span><span class="p">(</span><span class="n">hvib</span><span class="p">,</span> <span class="n">en_gap</span><span class="p">,</span> <span class="n">dNAC</span><span class="p">,</span> <span class="n">sc_nac_method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function scales the energies and NACs in the vibrionic Hamiltonian</span>
<span class="sd">    in the Chi basis. </span>

<span class="sd">    Args:   </span>
<span class="sd">        hvib ( list of CMATRIX objects ): </span>
<span class="sd">            CMATRIXlist of vibronic hamiltonians in the Chi basis</span>
<span class="sd">        en_gap ( float ): The desired energy gap (E_1 - E_0), for the Chi basis</span>
<span class="sd">        dNAC ( list of lists of (list, float) ):</span>
<span class="sd">            The scaling terms by which specific nacs will </span>
<span class="sd">            be scaled datatype = list of lists of (list, float)</span>

<span class="sd">            [  [ [i,j], val ], ...  ]          </span>

<span class="sd">            n and n+1 are the col (and thereby row) indicies of </span>
<span class="sd">            the nacs to be scaled by the value val </span>
<span class="sd">        sc_nac_method ( int ): The method used to scale NACs in the Chi basis, </span>
<span class="sd">            chosen by the user.</span>
<span class="sd">            If sc_nac_method = 1, then the NACs are scaled by the ivnerse of the</span>
<span class="sd">            magnitude of the change in energy, according to Lin et al.</span>

<span class="sd">            Reference: Lin, Y. &amp; Akimov, A. V. J. Phys. Chem. A (2016) </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">traj_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hvib</span><span class="p">)</span>

    <span class="c1"># Do the scaling</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_rows</span>
    <span class="n">ncols</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>   
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">traj_len</span><span class="p">):</span>

        <span class="n">prev_gap</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">en_gap</span> <span class="o">-</span> <span class="n">prev_gap</span> 

        <span class="c1"># Scale the energy gap, by adding the scaling factors to all excited states</span>
        <span class="c1"># This is to keep the ground state enegy equal to 0.0 by definition</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sc_nac_method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Scales nacs manually as set by user</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">dNAC</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sc_nac_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Scales nacs by the inverse of the change in energy gap</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="p">):</span>
                <span class="n">scl_nac</span> <span class="o">=</span> <span class="n">prev_gap</span> <span class="o">/</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">prev_gap</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">scl_nac</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scl_nac</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hvib</span>                    </div>


<div class="viewcode-block" id="compute_Hvib"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.compute_Hvib">[docs]</a><span class="k">def</span> <span class="nf">compute_Hvib</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">St_ks</span><span class="p">,</span> <span class="n">E_ks</span><span class="p">,</span> <span class="n">dE</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the vibronic Hamiltonian matrix</span>
<span class="sd">    </span>
<span class="sd">    Args:    </span>
<span class="sd">        basis ( list of lists of integers ): defines the basis of Slater Determinants, </span>
<span class="sd">            such that: basis[iSD][iks] is the indicator of the spin-orbital occupied by </span>
<span class="sd">            the electron iks in the Slater Determinant iSD</span>

<span class="sd">            Example: </span>

<span class="sd">                The following example defines a ground state SD (the lowest KS of the active space) and two </span>
<span class="sd">                single excitations, which are different from each other by two spin flips of the electrons</span>
<span class="sd">                The convention is to start indexing from 1 (corresponds to index 0 in the KS matrices)</span>
<span class="sd">                Positive - for alpha electrons, negative - for beta electrons</span>
<span class="sd">                Need to be consistent: [ -1, 2 ] and [ 2, -1 ] are treated differently, this is needed for spin-adaptation</span>

<span class="sd">                &gt;&gt; basis = [ [ 1,-1 ], [ 1,-2 ], [ 2,-1 ] ]</span>

<span class="sd">                The next example is for a system of 4 electrons and hole excitations</span>
<span class="sd">                &gt;&gt; basis = [ [ 1,-1, 2, -2 ], [ 3, -1, 2, -2 ], [ 1, -3, 2, -2 ] ]</span>

<span class="sd">                                                                       </span>
<span class="sd">        St_ks ( CMATRIX(2*norbs, 2*norbs) ): transition density matrix in the KS spin-orbitals basis, where </span>
<span class="sd">            norb - the number of double-occupied orbitals.</span>

<span class="sd">        E_ks ( CMATRIX(2*norbs, 2*norbs) ): the orbital energies in the KS spin-orbitals basis, where </span>
<span class="sd">            norb - the number of double-occupied orbitals.</span>

<span class="sd">        dE ( list of doubles ): define corrections of the SD state energies in comparison to </span>
<span class="sd">            the energy give by the sum energies of the occupied spin-orbitals.</span>
<span class="sd">            The convention is: dE[iSD] is the correction to energy of the SD with index iSD. </span>
<span class="sd">            This is a constant correction - same for all energies in the set [units: Ha] </span>

<span class="sd">            Example:</span>
<span class="sd">                For instance, for the SD examples above, the corrections could be:</span>
<span class="sd">                &gt;&gt; dE = [0.0, 0.01, 0.05]</span>

<span class="sd">        dt ( double ): the timestep for MD integrations [units: a.u.]</span>

<span class="sd">    Returns: </span>
<span class="sd">        CMATRIX(nstates, nstates) The Vibronic Hamiltonian</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">St</span>    <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">St_ks</span><span class="p">)</span> 
    <span class="n">H_el</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">E_ks</span><span class="p">,</span> <span class="n">dE</span><span class="p">)</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="n">H_el</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">j</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">CMATRIX</span><span class="p">((</span><span class="n">St</span><span class="o">-</span><span class="n">St</span><span class="o">.</span><span class="n">H</span><span class="p">())</span><span class="o">.</span><span class="n">real</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">H_vib</span></div>




<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.run">[docs]</a><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">S_dia_ks</span><span class="p">,</span> <span class="n">St_dia_ks</span><span class="p">,</span> <span class="n">E_dia_ks</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The procedure to converts the results of QE calculations (KS orbital energies and</span>
<span class="sd">    time-overlaps = transition density matrices in the KS basis) to the generic Hvib matrices, </span>
<span class="sd">    which (optionally) account for:   </span>

<span class="sd">    - enforces orthogonalization of the input KS states</span>
<span class="sd">    - state reordering</span>
<span class="sd">    - phase corrections</span>
<span class="sd">    - multi-electron wavefunction (Slater determinants) and spin-adaptation</span>

<span class="sd">    Args:</span>
<span class="sd">        S_dia_ks ( list of lists of CMATRIX objects ): overlaps of the KS orbitals along trajectories</span>
<span class="sd">            for each data set. Such that S_dia_ks[idata][istep].get(i,j) is &lt;i(istep)|j(istep)&gt; for the </span>
<span class="sd">            trajectory (=dataset) ```idata```.</span>

<span class="sd">        St_dia_ks ( list of lists of CMATRIX objects ): time-overlaps (=transition density matrices) </span>
<span class="sd">            in the basis of the KS orbitals along trajectories for each data set. </span>
<span class="sd">            Such that St_dia_ks[idata][istep].get(i,j) is &lt;i(istep)|j(istep+1)&gt; for the trajectory (=dataset) ```idata```.</span>

<span class="sd">        E_dia_ks ( list of lists of CMATRIX objects ): energies the KS orbitals at the mid-points along trajectories</span>
<span class="sd">            for each data set. Such that E_dia_ks[idata][istep].get(i,i) is 0.5*(E_i(istep) + E_i(istep+1)) for the </span>
<span class="sd">            trajectory (=dataset) ```idata```</span>

<span class="sd">        params ( dictionary ): Control paramerter of this type of simulation. Can include the follwing keys:</span>

<span class="sd">            * **params[&quot;SD_basis&quot;]** ( list of lists of ints ): define the Slater Determinants basis</span>
<span class="sd">                The convention is:  params[&quot;SD_basis&quot;][iSD][iks] is the indicator of the spin-orbital occupied by </span>
<span class="sd">                the electron iks in the Slater Determinant iSD [required!]</span>

<span class="sd">                Example: </span>

<span class="sd">                    The following example defines a ground state SD (the lowest KS of the active space) and two </span>
<span class="sd">                    single excitations, which are different from each other by two spin flips of the electrons</span>
<span class="sd">                    The convention is to start indexing from 1 (corresponds to index 0 in the KS matrices)</span>
<span class="sd">                    Positive - for alpha electrons, negative - for beta electrons</span>
<span class="sd">                    Need to be consistent: [ -1, 2 ] and [ 2, -1 ] are treated differently, this is needed for spin-adaptation</span>

<span class="sd">                    &gt;&gt; params[&quot;SD_basis&quot;] = [ [ 1,-1 ], [ 1,-2 ], [ 2,-1 ] ]</span>

<span class="sd">                    The next example is for a system of 4 electrons and hole excitations</span>
<span class="sd">                    &gt;&gt; params[&quot;SD_basis&quot;] = [ [ 1,-1, 2, -2 ], [ 3, -1, 2, -2 ], [ 1, -3, 2, -2 ] ]</span>


<span class="sd">            * **params[&quot;SD_energy_corr&quot;]** ( list of doubles ): define corrections of the SD state energies in comparison to </span>
<span class="sd">                the energy give by the sum energies of the occupied spin-orbitals.</span>
<span class="sd">                The convention is: params[&quot;SD_energy_corr&quot;][iSD] is the correction to energy of the SD with index iSD. </span>
<span class="sd">                This is a constant correction - same for all energies in the set [units: Ha] [required!]</span>

<span class="sd">                Example:</span>
<span class="sd">                    For instance, for the SD examples above, the corrections could be:</span>
<span class="sd">                    &gt;&gt; params[&quot;SD&quot;] = [0.0, 0.01, 0.05]</span>
<span class="sd">                                     </span>
<span class="sd">            * **params[&quot;CI_basis&quot;]** ( list of lists of complex number ): configuration interaction coefficients </span>
<span class="sd">                that define a superpositions to SDs that are considered the states of interest, e.g. spin-adapted configurations</span>
<span class="sd">                The convention is: params[&quot;CI_basis&quot;][iCI][iSD] is a coefficient of ```iSD```-th SD in the expansion of the CI</span>
<span class="sd">                with index ```iCI```. These coefficients don&#39;t have to account for the overal CI&#39;s normalization - the </span>
<span class="sd">                normalization will be done on the go. [required!]</span>

<span class="sd">                Example:</span>

<span class="sd">                    For the SD example above we can construct the following combinations:</span>
<span class="sd">                    &gt;&gt; params[&quot;CI_basis&quot;] = [ [1.0, 0.0, 0.0 ], </span>
<span class="sd">                                              [0.0, 1.0,-1.0 ],</span>
<span class="sd">                                              [0.0, 1.0, 1.0 ] </span>
<span class="sd">                                            ]</span>

<span class="sd">            * **params[&quot;output_set_paths&quot;]** ( list of strings ): the directory pathes where the resulting files </span>
<span class="sd">                are to be written (if so!). If you don&#39;t plan on writing the files, just provide a list of empty strings</span>
<span class="sd">                or whatever else - they will not be used in that case. The number of the strings should be equal to </span>
<span class="sd">                the number of the input data sets, e.g. to len(St_dia_ks)  [required!]</span>

<span class="sd">                  </span>
<span class="sd">            * **params[&quot;dt&quot;]** ( double ): nuclear dynamics integration time step [units: a.u. of time, default: 41.0]</span>
<span class="sd"> </span>
<span class="sd">            * **params[&quot;do_orthogonalization&quot;]** ( int ): the option to do Lowdin orthogonalization of the orbitals - using </span>
<span class="sd">                the &quot;raw&quot; overlaps (at the same time). This option is needed because the wavefunction output by QE are </span>
<span class="sd">                not exactly orthonormal (because of the use of pseudopotentials). So before we use them (implicitly) </span>
<span class="sd">                in the rest of the calculations here, we may need to account for this non-ideality effect.</span>
<span class="sd">                Options:</span>
<span class="sd">        </span>
<span class="sd">                - 0: don&#39;t do the orthogonalization - this is the same as in Pyxaid [default]</span>
<span class="sd">                - 1: do the orthogonalization</span>

<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): the option to control the state reordering</span>
<span class="sd">                Options:</span>

<span class="sd">                - 0: no state reordering - same as in Pyxaid</span>
<span class="sd">                - 1: older method (is not robust, may or may not work) </span>
<span class="sd">                - 2: Hungarian algorithm [default]</span>

<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): the parameter that controls the width of </span>
<span class="sd">                the energy interval within wich the state reordering is in effect. Zero value means all </span>
<span class="sd">                available orbitals, larger positive value decreases the width of the window. This parameter</span>
<span class="sd">                is not in effect unless the Hungarian algorithm is selected [default: 0.0]</span>

<span class="sd">            * **params[&quot;do_phase_correction&quot;]** ( int ): option to do the phase correction</span>

<span class="sd">                - 0 - don&#39;t do </span>
<span class="sd">                - 1 - do it [default]</span>

<span class="sd">            * **params[&quot;do_output&quot;]** ( int ): whether to print out the Hvib matrices ( = 1) to the files or not ( = 0).</span>

<span class="sd">            * **params[&quot;Hvib_re_prefix&quot;]** ( string ): common prefix of the output files with real part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;Hvib_&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_re_suffix&quot;]** ( string ): common suffix of the output files with real part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;_re&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_im_prefix&quot;]** ( string ): common prefix of the output files with imaginary part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;Hvib_&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_im_suffix&quot;]** ( string ): common suffix of the output files with imaginary part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;_im&quot;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of lists of CMATRIX(N,N): Hvib, such that:</span>
<span class="sd">            Hvib[idata][istep] is a CMATRIX(N,N) containing the vibronic Hamiltonian for the </span>
<span class="sd">            trajectory (dataset) ```idata``` and for the timestep ```istep```. Here, N is the number</span>
<span class="sd">            of states included in the active space.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#====== Defaults and local parameters ===============</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;SD_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">,</span> <span class="s2">&quot;CI_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;output_set_paths&quot;</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span><span class="mf">1.0</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">fs2au</span><span class="p">,</span> 
                       <span class="s2">&quot;do_orthogonalization&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                       <span class="s2">&quot;do_phase_correction&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                       <span class="s2">&quot;do_output&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_re&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_im&quot;</span><span class="p">,</span>

                     <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
 
    <span class="n">dt</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
    <span class="n">do_orthogonalization</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_orthogonalization&quot;</span><span class="p">]</span>
    <span class="n">do_phase_correction</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_phase_correction&quot;</span><span class="p">]</span>
    <span class="n">do_state_reordering</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span>
    <span class="n">ndata</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">)</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">])</span>  <span class="c1"># the number of CI states to consider</span>

    <span class="n">do_output</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_output&quot;</span><span class="p">]</span>

    <span class="c1">#====== Generic sanity checks ===============</span>
    <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: The number of output sets paths should be the same as the number of data sets</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ndata = &quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(params[</span><span class="se">\&quot;</span><span class="s2">output_set_paths</span><span class="se">\&quot;</span><span class="s2">]) = &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exiting...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



    <span class="c1">#====== Calculations  ===============</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idata</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ndata</span><span class="p">):</span>

        <span class="c1"># 1. Do the KS orbitals orthogonalization </span>
        <span class="k">if</span> <span class="n">do_orthogonalization</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_normalization</span><span class="p">(</span><span class="n">S_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">])</span>

        <span class="c1"># 2. Apply state reordering to KS</span>
        <span class="k">if</span> <span class="n">do_state_reordering</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_state_reordering</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">E_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># 3. Apply phase correction to KS</span>
        <span class="k">if</span> <span class="n">do_phase_correction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_phase_correction</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">])</span>
       
        
        <span class="n">Hvib</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
        
            <span class="c1"># 4. Construct the Hvib in the basis of Slater determinants (SDs)</span>
            <span class="n">hvib_sd</span> <span class="o">=</span> <span class="n">compute_Hvib</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">E_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span> 
      
            <span class="c1"># 5. Convert the Hvib to the basis of symmery-adapted configurations (SAC)</span>
            <span class="n">SD2CI</span> <span class="o">=</span> <span class="n">sac_matrices</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">S_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">hvib_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">hvib_sd</span> <span class="o">*</span> <span class="n">SD2CI</span>
            <span class="n">Hvib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">hvib_ci</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
            <span class="c1"># Output the resulting Hamiltonians</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
                <span class="n">re_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">]</span>
                <span class="n">im_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">]</span>        
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">re_filename</span><span class="p">)</span>
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>


        <span class="n">H_vib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hvib</span><span class="p">)</span>        
        
    <span class="k">return</span> <span class="n">H_vib</span></div>




<span class="k">def</span> <span class="nf">map_Hvib</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">dE</span><span class="p">):</span>

    <span class="n">nbasis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># doesn&#39;t matter</span>

    <span class="n">H_vib</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">dE</span><span class="p">)</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">Py2Cpp_int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">Py2Cpp_int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>

            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">sd2indx</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">nbasis</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> 
                    <span class="n">H_vib</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">H_vib</span>



<div class="viewcode-block" id="pyxaid2libra"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.pyxaid2libra">[docs]</a><span class="k">def</span> <span class="nf">pyxaid2libra</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#====== Defaults and local parameters ===============</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;SD_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">,</span> <span class="s2">&quot;CI_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;output_set_paths&quot;</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_output&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_re&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_im&quot;</span><span class="p">,</span>
                     <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

      
    <span class="n">ndata</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">)</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">norbs</span> <span class="o">=</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">])</span>  <span class="c1"># the number of CI states to consider</span>
    <span class="n">do_output</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_output&quot;</span><span class="p">]</span>


    <span class="n">S</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">norbs</span><span class="p">,</span> <span class="n">norbs</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">norbs</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">))</span>

    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

    <span class="c1">#====== Generic sanity checks ===============</span>
    <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: The number of output sets paths should be the same as the number of data sets</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ndata = &quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(params[</span><span class="se">\&quot;</span><span class="s2">output_set_paths</span><span class="se">\&quot;</span><span class="s2">]) = &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">])</span> <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exiting...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



    <span class="c1">#====== Calculations  ===============</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idata</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ndata</span><span class="p">):</span>

        <span class="n">Hvib</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
        
            <span class="c1"># 1. Construct the Hvib in the basis of Slater determinants (SDs)            </span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">hvib_sd</span> <span class="o">=</span> <span class="n">map_Hvib</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">])</span> 
      
            <span class="c1"># 2. Convert the Hvib to the basis of symmery-adapted configurations (SAC)</span>
            <span class="n">SD2CI</span> <span class="o">=</span> <span class="n">sac_matrices</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">hvib_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">hvib_sd</span> <span class="o">*</span> <span class="n">SD2CI</span>
            <span class="n">Hvib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">hvib_ci</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
            <span class="c1"># Output the resulting Hamiltonians</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
                <span class="n">re_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">]</span>
                <span class="n">im_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">]</span>        
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">re_filename</span><span class="p">)</span>
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>

        <span class="n">H_vib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hvib</span><span class="p">)</span>        
        
    <span class="k">return</span> <span class="n">H_vib</span></div>



<div class="viewcode-block" id="apply_state_reordering_general"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_state_reordering_general">[docs]</a><span class="k">def</span> <span class="nf">apply_state_reordering_general</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the state&#39;s identity reordering in a given basis for all time steps.</span>
<span class="sd">    This is reflects in the corresponding changess of the TDM.</span>

<span class="sd">    This function is for dat NOT in spin-block format</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(nstates, nstates) ): TDM for each timestep</span>
<span class="sd">        E ( list of CMATRIX(nstates, nstates) ): energies of all states at every step</span>
<span class="sd">        params ( dictionary ): parameters controlling the reordering</span>
<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): option to select the state reordering algorithm </span>
<span class="sd">                Available options:</span>
<span class="sd">                    - 1: older version developed by Kosuke Sato, may not the working all the times</span>
<span class="sd">                    - 2: Munkres-Kuhn (Hungarian) method [default]</span>
<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): a parameter that controls how </span>
<span class="sd">                many states will be included in the reordering</span>
<span class="sd">    Returns:</span>
<span class="sd">        None: but changes the input St object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span> <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

    <span class="n">nsteps</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span> 

    <span class="c1"># Initialize the cumulative permutation as the identity permutation</span>
    <span class="n">perm_cum</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for alpha spatial orbitals</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_cum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Current permutation</span>
    <span class="n">perm_t</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A simple approach based on permuations - but this is not robust</span>
<span class="sd">            may have loops</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">perm_t</span> <span class="o">=</span> <span class="n">get_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># apply the cumulative permutation  </span>
            <span class="n">update_permutation</span><span class="p">(</span><span class="n">perm_t</span><span class="p">,</span> <span class="n">perm_cum</span><span class="p">)</span>

            <span class="c1"># apply the permutation</span>
            <span class="c1"># Because St = &lt;psi(t)|psi(t+dt)&gt; - we permute only columns</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>

            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The Hungarian approach</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Permute rows </span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t</span><span class="p">)</span>

            <span class="c1"># compute the cost matrices</span>
            <span class="n">cost_mat</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>

            <span class="c1"># Solve the optimal assignment problem for diagonal blocks</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat</span><span class="p">)</span>

            <span class="c1"># Convert the list of lists into the permutation object</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">perm_t</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; i | i &gt; this becomes a new value: perm_t = P_{n+1}</span>

            <span class="c1"># Permute the blocks by col</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_phase_correction_general"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_phase_correction_general">[docs]</a><span class="k">def</span> <span class="nf">apply_phase_correction_general</span><span class="p">(</span><span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs the phase correction according to:         </span>
<span class="sd">    Akimov, A. V. J. Phys. Chem. Lett, 2018, 9, 6096</span>

<span class="sd">    This function is for dat NOT in spin-block format</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(N,N) ): St_ij[n] = &lt;i(n)|j(n+1)&gt; transition density matrix for </span>
<span class="sd">            the timestep n, where N is the number of states in the active space. </span>
<span class="sd">            Spin-orbitals, not just orbitals! So it is composed as:</span>

<span class="sd">    Returns: </span>
<span class="sd">        None: but changes the input St matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>

    <span class="c1">### Initiate the cumulative phase correction factors ###    </span>
    <span class="n">cum_phase</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># F(n-1)  cumulative phase</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">cum_phase</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of steps , nsteps= &quot;</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="c1">### Compute the instantaneous phase correction factors for diag. blocks ###</span>
        <span class="n">phase_i</span> <span class="o">=</span> <span class="n">compute_phase_corrections</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># f(i)</span>

        <span class="n">phase_i</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">()</span>

        <span class="c1">### Do the  phase corrections ###</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase</span><span class="p">,</span> <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cum_phase</span><span class="p">,</span> <span class="n">phase_i</span><span class="p">)</span>

        <span class="c1">### Update the cumulative phase correction factors for diag. blocks ###</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">cum_phase</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phase_i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">))</span></div>





<div class="viewcode-block" id="sort_unique_SD_basis"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.sort_unique_SD_basis">[docs]</a><span class="k">def</span> <span class="nf">sort_unique_SD_basis</span><span class="p">(</span> <span class="n">E_ks</span><span class="p">,</span> <span class="n">sd_states_unique</span><span class="p">,</span> <span class="n">sd_states_reindexed</span><span class="p">,</span> <span class="n">istep</span><span class="p">,</span> <span class="n">fstep</span><span class="p">,</span> <span class="n">sorting_type</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the energies of the SP transitions (according to the sum of 1 electron terms) - no J or K</span>
<span class="sd">        It then may sort the order of the sd_states either based on their energy at each timestep</span>
<span class="sd">       </span>
<span class="sd">        Args:</span>
<span class="sd">            E_ks (list of CMATRIX): KS orbital energies at each timestep. Spin block style </span>
<span class="sd">                                                                          Ex)     [ alp*alp  alp*bet ]</span>
<span class="sd">                                                                                  [ bet*alp  bet*bet ]</span>
<span class="sd">            sd_states_unique (list of lists): all SP transitions and which spin it was</span>
<span class="sd">                                              Ex) [ [ [&#39;28 29&#39;], [&#39;alp&#39;] ]. [ [&#39;28 30&#39;], [&#39;alp&#39;] ] ]</span>
<span class="sd">            sd_states_reindexed (list of lists): sd_states_unique but in internal  Libra notation </span>
<span class="sd">                                                  Ex) [ [1,-1,3,-2], [3,-1,2,-2] ]</span>
<span class="sd">            sorting_type ( (string) ): &quot;energy&quot;   - sort by energy</span>
<span class="sd">                                       &quot;identity&quot; - sort by identity</span>

<span class="sd">            istep (int): step from which to start counting</span>
<span class="sd">            fstep (int): step at which to stop counting</span>
<span class="sd"> </span>
<span class="sd">        Returns:       </span>
<span class="sd">            E_sd (list of CMATRIX): SD energies at each timestep</span>
<span class="sd">            sd_states_unique_sorted (list of lists): All SP transitions and which spin it is, but now sorted either by identity (no sorting) or energy</span>
<span class="sd">            sd_states_reindexed_sorted (list of lists): The sd_states_unique_sorted, but in Libra&#39;s notation</span>
<span class="sd">            reindex_nsteps (list of lists): The energy ordering of the SD for each step in terms of the index of the SD from the initial step</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_sd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sd_states_reindexed_sorted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sd_states_unique_sorted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">SD_energy_corr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sd_states_reindexed</span><span class="p">)</span>
    <span class="n">nstates_sd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sd_states_reindexed</span><span class="p">)</span>
    <span class="n">reindex_nsteps</span> <span class="o">=</span> <span class="p">[]</span>     

    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">fstep</span> <span class="o">-</span> <span class="n">istep</span> <span class="p">):</span>

        <span class="c1"># Append a CMATRIX of dimension nstates_sd x nstates_sd</span>
        <span class="n">E_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nstates_sd</span><span class="p">,</span> <span class="n">nstates_sd</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1"># At this step, compute the energy of the SD</span>
        <span class="n">E_this_sd</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span> <span class="n">sd_states_reindexed</span><span class="p">,</span> <span class="n">E_ks</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">SD_energy_corr</span> <span class="p">)</span>

        <span class="c1"># Make a list for the final ordering of the sd_states_unique.</span>
        <span class="c1"># This will not contain the ground state, which we will manually add later. </span>
        <span class="n">sd_states_unique_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        <span class="n">sd_states_reindexed_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>

        <span class="c1"># Make an array of zeros, these will be overwritten with the energy of each SD</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">nstates_sd</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates_sd</span><span class="p">):</span>
            <span class="n">e</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span>  <span class="n">E_this_sd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
            <span class="c1"># Obtain the indexing fo the SDs by their energies</span>
        <span class="n">reindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sorting_type</span> <span class="o">==</span> <span class="s2">&quot;identity&quot;</span><span class="p">:</span>

            <span class="n">reindex_nsteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates_sd</span><span class="p">))</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates_sd</span><span class="p">):</span>

                <span class="c1"># This is making the energy matrix. And the &quot;sorted&quot; sds (written in Libra&#39;s input format) are just appened</span>
                <span class="c1"># to sd_states_reindexed_sorted[step]. For identity ordering - no energy sorting is done!</span>
                <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>  <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">E_this_sd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_states_reindexed</span><span class="p">[</span> <span class="n">state</span> <span class="p">]</span> <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span> <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span> <span class="n">state</span> <span class="p">],</span> <span class="p">(</span> <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span> <span class="p">)</span> <span class="o">-</span> <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">au2ev</span> <span class="p">)</span>

                <span class="c1"># This is reindexing the list of SD bases at this time step according to their energies </span>
                <span class="c1"># We are adding the ground state SD later, so skip it for now. In this list sd_states_unique,</span>
                <span class="c1"># the ground state is not there - this list is the single-particle transitions (and spin) given by the</span>
                <span class="c1"># ES software. So, for example, if nstates_sd = 4, we take only the first 3, because the ground state is not</span>
                <span class="c1"># in sd_states_unique</span>
                <span class="c1"># Ex) sd_states_unique = [  [ [&#39;28,29&#39;], [&#39;alp&#39;] ] , [ [&#39;27,29&#39;], [&#39;alp&#39;] ] , [ [&#39;26,29&#39;], [&#39;alp&#39;] ] ]    </span>
                <span class="c1"># 28 = homo</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="n">nstates_sd</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_states_unique</span><span class="p">[</span> <span class="n">state</span> <span class="p">]</span> <span class="p">)</span>

        <span class="k">elif</span> <span class="n">sorting_type</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>

            <span class="n">reindex_nsteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reindex</span> <span class="p">)</span>

            <span class="c1"># For each SD basis, make the energy matrix and reindex the list of basis according to their energies</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reindex</span><span class="p">)):</span>
                <span class="c1"># This is making the energy matrix</span>
                <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">E_this_sd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>  <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">)</span>
                <span class="c1"># This is reindexing the list of SD bases at this time step according to their energies </span>
                <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_states_reindexed</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">]</span> <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span> <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span> <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="o">-</span> <span class="n">E_sd</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">au2ev</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">reindex</span><span class="p">)):</span>
                <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_states_unique</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="p">)</span>


    <span class="k">return</span> <span class="n">E_sd</span><span class="p">,</span> <span class="n">sd_states_unique_sorted</span><span class="p">,</span> <span class="n">sd_states_reindexed_sorted</span><span class="p">,</span> <span class="n">reindex_nsteps</span></div>





<div class="viewcode-block" id="make_T_matricies"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.make_T_matricies">[docs]</a><span class="k">def</span> <span class="nf">make_T_matricies</span><span class="p">(</span> <span class="n">ci_coefficients</span><span class="p">,</span> <span class="n">ci_basis_states</span><span class="p">,</span> <span class="n">spin_components</span><span class="p">,</span> <span class="n">sd_states_unique_sorted</span><span class="p">,</span> <span class="n">nstates</span><span class="p">,</span> <span class="n">istep</span><span class="p">,</span> <span class="n">fstep</span><span class="p">,</span> <span class="n">outdir</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function makes the &quot;T&quot;ransformation matricies that convert between the SD basis to the CI-like (or many-body (MB)) basis.</span>

<span class="sd">    This funciton is made to be used within the NBRA Libra workflow, where things such as ci_coefficients, ci_basis_states, spin_components, </span>
<span class="sd">    and sd_states_unique_sorted have been extracted from TD-DFT calculations. As of 11/30/2020, compatable ES programs</span>
<span class="sd">    include CP2K, DFTB+ and Gaussian.</span>

<span class="sd">    Args:</span>
<span class="sd">        ci_coefficients (list of lists of lists): coefficients for the many-body states for each step</span>
<span class="sd">        ci_basis_states (list of lists): All SD basis states that comprise the many-body excitations for each step</span>
<span class="sd">        spin_components (list of lists): the spin components of the excitation (alpha or beta excitaiton?) for all states and all steps  </span>
<span class="sd">        sd_basis_states_unique (list): 1 of each of the SP transitions (and its spin) that made up the considered CI states</span>
<span class="sd">        nstates (int): number of excited MB states</span>
<span class="sd">        istep (int): step at which to start counting</span>
<span class="sd">        fstep (int): stap at which to stop counting</span>
<span class="sd">        outdir (string): output directory for the T matricies</span>
<span class="sd">        verbose (int): want to see some messages?</span>

<span class="sd">    Returns:</span>
<span class="sd">        SD2CI (list of CMATRIX): CMATRIX at each timestep where the rows are SDs and the cols are MB states. The columns contain the coefficients of the MB expansion for each MB state</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">number_of_states</span> <span class="o">=</span> <span class="n">nstates</span>
    <span class="n">ci_coefficients_libra</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nSDs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># Add one to the number of CI states because the ground state is not included yet</span>
    <span class="n">nCIs</span>  <span class="o">=</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">SD2CI</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">fstep</span> <span class="o">-</span> <span class="n">istep</span> <span class="p">):</span>

        <span class="c1"># Make the list of ci_coefficients for each step in the way Libra accepts</span>
        <span class="n">ci_coefficients_libra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        <span class="c1"># Start with the ground state. This is not explicitly given by electronic strcture calculations</span>
        <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nSDs</span> <span class="p">)</span>
        <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># For each ci state for this step</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># The ci wavefunction is a linear combination of SD states. Make a list of zeros the size of the number of unique</span>
            <span class="c1"># SD states + 1 for the ground state</span>
            <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nSDs</span> <span class="p">)</span>
            <span class="c1"># Exclude ground state here in the index, that info is not explicitly contained </span>
            <span class="c1"># in the ci_coefficients_dynamics list from electronic structure calculations</span>
            <span class="n">tmp_ci_basis_state_and_spin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># For each ci_coefficient in this ci state for this step, get the ci coefficients and spin (alp or bet)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">tmp_ci_basis_state_and_spin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">ci_basis_states</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="p">,</span> <span class="n">spin_components</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span> <span class="p">)</span>
            <span class="c1"># Now, loop over the SDs (excluding the ground state) to assign the coefficients</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSDs</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
                <span class="c1"># Check to see if one of the SDs from the list of unique SDs comprises this ci state</span>
                <span class="k">if</span> <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tmp_ci_basis_state_and_spin</span><span class="p">:</span>
                    <span class="c1"># ok, it has found a match, now what is the index of the SD in the list of unique SDs?</span>
                    <span class="n">item_index</span> <span class="o">=</span> <span class="n">tmp_ci_basis_state_and_spin</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">item_index</span><span class="p">])</span>


        <span class="c1"># Sanity check. Make sure sum of squared elements of columns == 1:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nCIs</span> <span class="p">):</span>
            <span class="n">check_norm</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSDs</span> <span class="p">):</span>
                <span class="n">check_norm</span> <span class="o">+=</span> <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;check_norm&quot;</span><span class="p">,</span> <span class="n">check_norm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_norm</span> <span class="o">&lt;</span> <span class="mf">0.99</span> <span class="ow">or</span> <span class="n">check_norm</span> <span class="o">&gt;</span> <span class="mf">1.01</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Step, &quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Column &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;in SD2Ci (T) matrix has norm either &lt; 0.99 or &gt; 1.01&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exiting now&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">SD2CI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nSDs</span><span class="p">,</span> <span class="n">nCIs</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSDs</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nCIs</span> <span class="p">):</span>
                <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ci_coefficients_libra</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Output the transformation matrix. This is how you can double check that it worked ( it does ... :) )</span>
        <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/T_</span><span class="si">%s</span><span class="s2">.txt&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">step</span><span class="p">))</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">SD2CI</span></div>




<div class="viewcode-block" id="compute_ci_energies_midpoint"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.compute_ci_energies_midpoint">[docs]</a><span class="k">def</span> <span class="nf">compute_ci_energies_midpoint</span><span class="p">(</span> <span class="n">ci_energies</span><span class="p">,</span> <span class="n">num_excited_states</span><span class="p">,</span> <span class="n">istep</span><span class="p">,</span> <span class="n">fstep</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function compute the excitation energies energies at the midpoint from a list of excitation energies at each step. </span>
<span class="sd">    At each step, there are many electronic states. This function takes a list as an input, and is meant to be used </span>
<span class="sd">    in the NBRA workflow calculatiosn where lists may be more convenient than matricies. </span>

<span class="sd">    This funciton is made to be used within the NBRA Libra workflow, where things such as ci_energies have been extracted from TD-DFT calculations. </span>
<span class="sd">    As of 11/30/2020, compatable ES programs include CP2K, DFTB+ and Gaussian.</span>

<span class="sd">    Energies are assumed to be energies from TDDFT calculatons. This function gives zero as the ground state total energy</span>

<span class="sd">    Args:</span>
<span class="sd">        ci_energies (list of lists): energies of the MB states</span>
<span class="sd">        num_excited_states (int): number of excited states</span>
<span class="sd">        istep (int): step at which to start counting</span>
<span class="sd">        fstep (int): stap at which to stop counting</span>

<span class="sd">    Returns:</span>
<span class="sd">        ci_midpoint_energies (list of CMATRIX): energies in Ha. Ground state energy is set to zero</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="n">num_excited_states</span>

    <span class="c1"># Now, compute the CI energy matrix at each-point and the mid-points</span>
    <span class="c1"># For each step</span>
    <span class="c1">#print(&quot;Computing the CI energy matrices....&quot;)</span>
    <span class="n">ci_energies_cmatrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">fstep</span> <span class="o">-</span> <span class="n">istep</span> <span class="p">):</span>
        <span class="n">ci_energies_cmatrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ci_energies_cmatrix</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ci_energies_cmatrix</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="p">(</span> <span class="n">ci_energies</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">ev2Ha</span> <span class="p">)</span>  <span class="p">)</span>

    <span class="c1"># At the midpoints</span>
    <span class="n">ci_midpoint_energies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">fstep</span> <span class="o">-</span> <span class="n">istep</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">):</span>
        <span class="n">total_energy_mid_point</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1">#0.5 * ( total_energies[step] + total_energies[step+1] )</span>
        <span class="n">ci_midpoint_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nstates</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ci_midpoint_energies</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energy_mid_point</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">midpoint_energy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="n">ci_energies</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ci_energies</span><span class="p">[</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">ci_midpoint_energies</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energy_mid_point</span> <span class="o">+</span> <span class="p">(</span> <span class="n">midpoint_energy</span>  <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">ev2Ha</span> <span class="p">)</span>  <span class="p">)</span>

    <span class="k">return</span> <span class="n">ci_midpoint_energies</span></div>


</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Alexey V. Akimov.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>