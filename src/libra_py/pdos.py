#*********************************************************************************
#* Copyright (C) 2018 Alexey V. Akimov
#*
#* This file is distributed under the terms of the GNU General Public License
#* as published by the Free Software Foundation, either version 2 of
#* the License, or (at your option) any later version.
#* See the file LICENSE in the root directory of this distribution
#* or <http://www.gnu.org/licenses/>.
#*
#*********************************************************************************/
## \file pdos.py
# This module implements functions for computing projected densities of states from various outputs

import math
import os
import sys
if sys.platform=="cygwin":
    from cyglibra_core import *
elif sys.platform=="linux" or sys.platform=="linux2":
    from liblibra_core import *


def convolve(X0, Y0, dx0, dx, var):
    """
    This function convolves the original data with the Gaussian
    of a given width:  exp(- (x - x0)^2 / (2*var^2) )

    X0   [MATRIX(N, 1)]     - original X grid
    Y0   [MATRIX(N, Nproj)] - original Y grids
    dx0  [double]           - original X grid spacing
    dx   [double]           - new X grid spacing
    var  [double]           - width of the Gaussians
    """

    mult = int(dx0/dx)     # making grid mult times bigger
    print "multiplication factor is = ", mult
    print "original grid spacing = ", dx0
    print "new grid spacing = ", dx
    print "gaussian variance = ", var
        
    # Prepare arrays
    N0    = Y0.num_of_rows     # how many original grid points
    nproj = Y0.num_of_cols     # how many components
    N  = N0*mult               # how many new grid points

    X = MATRIX(N, 1)           # new X axis
    Y = MATRIX(N, nproj)       # new Y axes


    for i in xrange(N):
        X.set(i,0, X0.get(0,0) + i*dx)


    area = var*math.sqrt(2.0*math.pi)  # area under Gaussian of type exp( -(x - x0)^2 / 2*var^2 ) 
    alp = 0.5/(var**2)

    for j in xrange(nproj):  

        for i0 in xrange(N0):   # all initial grid points
            x0 = X0.get(i0, 0)
            y0 = Y0.get(i0, j)

            area0 = dx0*y0      # initial area
            w = area0/area

            for i in xrange(N):
                x = X.get(i, 0)
                Y.add(i,j, w*math.exp(-alp*(x0-x)**2))

    return X, Y



def QE_pdos(prefix, emin, emax, de, projections, Ef, outfile, do_convolve, de_new, var):
    """
    Computes various types of pDOS from the atomic state projections generated by the QE

    prefix [string]   - points to the files containing projection information
    emin   [double]   - minimal energy of the pDOS window [eV]
    emax   [double]   - maximal energy of the pDOS window [eV]
    de     [double]   - the original grid spacing of the pDOS [eV] (not necessarily the one used in pdos.in)

    projections [list of lists] - groups of atoms and types of projections

    Each element of this list contains 3 sub-lists, whose intersection defines which files to use:
    e.g. projections = [["s","p"], [1,2,3], ["Cs", "Br"]] - means s and p orbitals of atoms 1, 2, and 3
    as long as any of these atoms are Cs or Br

    outfile [string]  - the name of the file that'll contain the final projections
    do_convolve [Bool]- the flag telling whether we want to convolve the original data with the Gaussian envelope
    de_new  [double]  - the new energy grid spacing [eV], in effect only if do_convolve == True
    var     [double]  - standard deviation of the Gaussian [eV] with which we do a convolution, in effect only if do_convolve == True

    """

    #============= Dimensions  =================

    nproj = len(projections)                # number of projections
    N = int(math.floor((emax - emin)/de))+1 # number of the gridpoints

    en = MATRIX(N, 1)       # energy of the grid points
    dos = MATRIX(N, nproj)  # dos.get(i,proj) - dos for level i projected on projection proj
    for i in range(0,N):
        en.set(i, 0, emin + i*de - Ef)


    #============= Data gathering  =================
    
    for proj in projections:  # loop over all projection
        ang_mom = proj[0]
        atoms = proj[1]
        elements = proj[2]

        proj_indx = projections.index(proj)

        for a in atoms: # open files for atoms with given indices (indexing from 1)
            for symb in ang_mom:  # for given angular momentum labels
                for wfc in range(0,5): # Specify max wfc type index - usually no more than 3, 5 - should be more than enough  
                    for Elt in elements: # for given atom names
                        filename = prefix+str(a)+"("+Elt+")_wfc#"+str(wfc)+"("+symb+")"  # file
                    
                        if os.path.exists(filename):
            
                            fa = open(filename,"r")
                            B = fa.readlines()
                            fa.close()

                            for lin in B[1:]:  # read all lines, except for the header
                                tmp = lin.split()
                 
                                e = float(tmp[0])
                                if e<emin or e>emax:
                                    pass
                                else:
                                    state_indx = int(math.floor((e - emin)/de))
                                    dos.add(state_indx, proj_indx, float(tmp[1]))


    #============= Optional convolution =================

    E, pDOS = en, dos
    if do_convolve==True:
        E, pDOS = convolve(en, dos, de, de_new, var)


    #============= Print out ==================
    f2 = open(outfile,"w")
    f2.close()

    N = E.num_of_rows
    for i in range(0,N):  # loop over grid points

        line = str(E.get(i,0))+"   "

        tot = 0.0
        for j in range(0,nproj):
            tot = tot + pDOS.get(i,j)
            line = line + str(pDOS.get(i,j))+"   "

        line = line + str(tot)+"\n"

        f2 = open(outfile,"a")
        f2.write(line)
        f2.close()


    return E, pDOS

